// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package com.bdmplatform.api.grpc

@SerialVersionUID(0L)
final case class BalanceResponse(
    balance: com.bdmplatform.api.grpc.BalanceResponse.Balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Empty
    ) extends scalapb.GeneratedMessage with scalapb.Message[BalanceResponse] with scalapb.lenses.Updatable[BalanceResponse] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      if (balance.bdm.isDefined) {
        val __value = balance.bdm.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (balance.asset.isDefined) {
        val __value = balance.asset.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size
    }
    final override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      balance.bdm.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      balance.asset.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.bdmplatform.api.grpc.BalanceResponse = {
      var __balance = this.balance
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Bdm(_root_.scalapb.LiteParser.readMessage(_input__, balance.bdm.getOrElse(com.bdmplatform.api.grpc.BalanceResponse.BdmBalances.defaultInstance)))
          case 18 =>
            __balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Asset(_root_.scalapb.LiteParser.readMessage(_input__, balance.asset.getOrElse(com.bdmplatform.protobuf.Amount.defaultInstance)))
          case tag => _input__.skipField(tag)
        }
      }
      com.bdmplatform.api.grpc.BalanceResponse(
          balance = __balance
      )
    }
    def getBdm: com.bdmplatform.api.grpc.BalanceResponse.BdmBalances = balance.bdm.getOrElse(com.bdmplatform.api.grpc.BalanceResponse.BdmBalances.defaultInstance)
    def withBdm(__v: com.bdmplatform.api.grpc.BalanceResponse.BdmBalances): BalanceResponse = copy(balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Bdm(__v))
    def getAsset: com.bdmplatform.protobuf.Amount = balance.asset.getOrElse(com.bdmplatform.protobuf.Amount.defaultInstance)
    def withAsset(__v: com.bdmplatform.protobuf.Amount): BalanceResponse = copy(balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Asset(__v))
    def clearBalance: BalanceResponse = copy(balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Empty)
    def withBalance(__v: com.bdmplatform.api.grpc.BalanceResponse.Balance): BalanceResponse = copy(balance = __v)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => balance.bdm.orNull
        case 2 => balance.asset.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => balance.bdm.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => balance.asset.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = com.bdmplatform.api.grpc.BalanceResponse
}

object BalanceResponse extends scalapb.GeneratedMessageCompanion[com.bdmplatform.api.grpc.BalanceResponse] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[com.bdmplatform.api.grpc.BalanceResponse] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, _root_.scala.Any]): com.bdmplatform.api.grpc.BalanceResponse = {
    _root_.scala.Predef.require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    com.bdmplatform.api.grpc.BalanceResponse(
      balance = __fieldsMap.get(__fields.get(0)).asInstanceOf[_root_.scala.Option[com.bdmplatform.api.grpc.BalanceResponse.BdmBalances]].map(com.bdmplatform.api.grpc.BalanceResponse.Balance.Bdm)
    .orElse[com.bdmplatform.api.grpc.BalanceResponse.Balance](__fieldsMap.get(__fields.get(1)).asInstanceOf[_root_.scala.Option[com.bdmplatform.protobuf.Amount]].map(com.bdmplatform.api.grpc.BalanceResponse.Balance.Asset))
    .getOrElse(com.bdmplatform.api.grpc.BalanceResponse.Balance.Empty)
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[com.bdmplatform.api.grpc.BalanceResponse] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      com.bdmplatform.api.grpc.BalanceResponse(
        balance = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[com.bdmplatform.api.grpc.BalanceResponse.BdmBalances]]).map(com.bdmplatform.api.grpc.BalanceResponse.Balance.Bdm)
    .orElse[com.bdmplatform.api.grpc.BalanceResponse.Balance](__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[com.bdmplatform.protobuf.Amount]]).map(com.bdmplatform.api.grpc.BalanceResponse.Balance.Asset))
    .getOrElse(com.bdmplatform.api.grpc.BalanceResponse.Balance.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = AccountsApiProto.javaDescriptor.getMessageTypes.get(3)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = AccountsApiProto.scalaDescriptor.messages(3)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = com.bdmplatform.api.grpc.BalanceResponse.BdmBalances
      case 2 => __out = com.bdmplatform.protobuf.Amount
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_]] = Seq[_root_.scalapb.GeneratedMessageCompanion[_]](
    _root_.com.bdmplatform.api.grpc.BalanceResponse.BdmBalances
  )
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = com.bdmplatform.api.grpc.BalanceResponse(
  )
  sealed trait Balance extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isBdm: _root_.scala.Boolean = false
    def isAsset: _root_.scala.Boolean = false
    def bdm: _root_.scala.Option[com.bdmplatform.api.grpc.BalanceResponse.BdmBalances] = None
    def asset: _root_.scala.Option[com.bdmplatform.protobuf.Amount] = None
  }
  object Balance extends {
    @SerialVersionUID(0L)
    case object Empty extends com.bdmplatform.api.grpc.BalanceResponse.Balance {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class Bdm(value: com.bdmplatform.api.grpc.BalanceResponse.BdmBalances) extends com.bdmplatform.api.grpc.BalanceResponse.Balance {
      type ValueType = com.bdmplatform.api.grpc.BalanceResponse.BdmBalances
      override def isBdm: _root_.scala.Boolean = true
      override def bdm: _root_.scala.Option[com.bdmplatform.api.grpc.BalanceResponse.BdmBalances] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class Asset(value: com.bdmplatform.protobuf.Amount) extends com.bdmplatform.api.grpc.BalanceResponse.Balance {
      type ValueType = com.bdmplatform.protobuf.Amount
      override def isAsset: _root_.scala.Boolean = true
      override def asset: _root_.scala.Option[com.bdmplatform.protobuf.Amount] = Some(value)
      override def number: _root_.scala.Int = 2
    }
  }
  @SerialVersionUID(0L)
  final case class BdmBalances(
      regular: _root_.scala.Long = 0L,
      generating: _root_.scala.Long = 0L,
      available: _root_.scala.Long = 0L,
      effective: _root_.scala.Long = 0L,
      leaseIn: _root_.scala.Long = 0L,
      leaseOut: _root_.scala.Long = 0L
      ) extends scalapb.GeneratedMessage with scalapb.Message[BdmBalances] with scalapb.lenses.Updatable[BdmBalances] {
      @transient
      private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
      private[this] def __computeSerializedValue(): _root_.scala.Int = {
        var __size = 0
        
        {
          val __value = regular
          if (__value != 0L) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(1, __value)
          }
        };
        
        {
          val __value = generating
          if (__value != 0L) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(2, __value)
          }
        };
        
        {
          val __value = available
          if (__value != 0L) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(3, __value)
          }
        };
        
        {
          val __value = effective
          if (__value != 0L) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(4, __value)
          }
        };
        
        {
          val __value = leaseIn
          if (__value != 0L) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(5, __value)
          }
        };
        
        {
          val __value = leaseOut
          if (__value != 0L) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(6, __value)
          }
        };
        __size
      }
      final override def serializedSize: _root_.scala.Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
        {
          val __v = regular
          if (__v != 0L) {
            _output__.writeInt64(1, __v)
          }
        };
        {
          val __v = generating
          if (__v != 0L) {
            _output__.writeInt64(2, __v)
          }
        };
        {
          val __v = available
          if (__v != 0L) {
            _output__.writeInt64(3, __v)
          }
        };
        {
          val __v = effective
          if (__v != 0L) {
            _output__.writeInt64(4, __v)
          }
        };
        {
          val __v = leaseIn
          if (__v != 0L) {
            _output__.writeInt64(5, __v)
          }
        };
        {
          val __v = leaseOut
          if (__v != 0L) {
            _output__.writeInt64(6, __v)
          }
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.bdmplatform.api.grpc.BalanceResponse.BdmBalances = {
        var __regular = this.regular
        var __generating = this.generating
        var __available = this.available
        var __effective = this.effective
        var __leaseIn = this.leaseIn
        var __leaseOut = this.leaseOut
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __regular = _input__.readInt64()
            case 16 =>
              __generating = _input__.readInt64()
            case 24 =>
              __available = _input__.readInt64()
            case 32 =>
              __effective = _input__.readInt64()
            case 40 =>
              __leaseIn = _input__.readInt64()
            case 48 =>
              __leaseOut = _input__.readInt64()
            case tag => _input__.skipField(tag)
          }
        }
        com.bdmplatform.api.grpc.BalanceResponse.BdmBalances(
            regular = __regular,
            generating = __generating,
            available = __available,
            effective = __effective,
            leaseIn = __leaseIn,
            leaseOut = __leaseOut
        )
      }
      def withRegular(__v: _root_.scala.Long): BdmBalances = copy(regular = __v)
      def withGenerating(__v: _root_.scala.Long): BdmBalances = copy(generating = __v)
      def withAvailable(__v: _root_.scala.Long): BdmBalances = copy(available = __v)
      def withEffective(__v: _root_.scala.Long): BdmBalances = copy(effective = __v)
      def withLeaseIn(__v: _root_.scala.Long): BdmBalances = copy(leaseIn = __v)
      def withLeaseOut(__v: _root_.scala.Long): BdmBalances = copy(leaseOut = __v)
      def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => {
            val __t = regular
            if (__t != 0L) __t else null
          }
          case 2 => {
            val __t = generating
            if (__t != 0L) __t else null
          }
          case 3 => {
            val __t = available
            if (__t != 0L) __t else null
          }
          case 4 => {
            val __t = effective
            if (__t != 0L) __t else null
          }
          case 5 => {
            val __t = leaseIn
            if (__t != 0L) __t else null
          }
          case 6 => {
            val __t = leaseOut
            if (__t != 0L) __t else null
          }
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PLong(regular)
          case 2 => _root_.scalapb.descriptors.PLong(generating)
          case 3 => _root_.scalapb.descriptors.PLong(available)
          case 4 => _root_.scalapb.descriptors.PLong(effective)
          case 5 => _root_.scalapb.descriptors.PLong(leaseIn)
          case 6 => _root_.scalapb.descriptors.PLong(leaseOut)
        }
      }
      def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
      def companion = com.bdmplatform.api.grpc.BalanceResponse.BdmBalances
  }
  
  object BdmBalances extends scalapb.GeneratedMessageCompanion[com.bdmplatform.api.grpc.BalanceResponse.BdmBalances] {
    implicit def messageCompanion: scalapb.GeneratedMessageCompanion[com.bdmplatform.api.grpc.BalanceResponse.BdmBalances] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, _root_.scala.Any]): com.bdmplatform.api.grpc.BalanceResponse.BdmBalances = {
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      com.bdmplatform.api.grpc.BalanceResponse.BdmBalances(
        __fieldsMap.getOrElse(__fields.get(0), 0L).asInstanceOf[_root_.scala.Long],
        __fieldsMap.getOrElse(__fields.get(1), 0L).asInstanceOf[_root_.scala.Long],
        __fieldsMap.getOrElse(__fields.get(2), 0L).asInstanceOf[_root_.scala.Long],
        __fieldsMap.getOrElse(__fields.get(3), 0L).asInstanceOf[_root_.scala.Long],
        __fieldsMap.getOrElse(__fields.get(4), 0L).asInstanceOf[_root_.scala.Long],
        __fieldsMap.getOrElse(__fields.get(5), 0L).asInstanceOf[_root_.scala.Long]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[com.bdmplatform.api.grpc.BalanceResponse.BdmBalances] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        com.bdmplatform.api.grpc.BalanceResponse.BdmBalances(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Long]).getOrElse(0L)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = com.bdmplatform.api.grpc.BalanceResponse.javaDescriptor.getNestedTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = com.bdmplatform.api.grpc.BalanceResponse.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
    lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_]] = Seq.empty
    def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = com.bdmplatform.api.grpc.BalanceResponse.BdmBalances(
    )
    implicit class BdmBalancesLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, com.bdmplatform.api.grpc.BalanceResponse.BdmBalances]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, com.bdmplatform.api.grpc.BalanceResponse.BdmBalances](_l) {
      def regular: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.regular)((c_, f_) => c_.copy(regular = f_))
      def generating: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.generating)((c_, f_) => c_.copy(generating = f_))
      def available: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.available)((c_, f_) => c_.copy(available = f_))
      def effective: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.effective)((c_, f_) => c_.copy(effective = f_))
      def leaseIn: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.leaseIn)((c_, f_) => c_.copy(leaseIn = f_))
      def leaseOut: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.leaseOut)((c_, f_) => c_.copy(leaseOut = f_))
    }
    final val REGULAR_FIELD_NUMBER = 1
    final val GENERATING_FIELD_NUMBER = 2
    final val AVAILABLE_FIELD_NUMBER = 3
    final val EFFECTIVE_FIELD_NUMBER = 4
    final val LEASE_IN_FIELD_NUMBER = 5
    final val LEASE_OUT_FIELD_NUMBER = 6
    def of(
      regular: _root_.scala.Long,
      generating: _root_.scala.Long,
      available: _root_.scala.Long,
      effective: _root_.scala.Long,
      leaseIn: _root_.scala.Long,
      leaseOut: _root_.scala.Long
    ): _root_.com.bdmplatform.api.grpc.BalanceResponse.BdmBalances = _root_.com.bdmplatform.api.grpc.BalanceResponse.BdmBalances(
      regular,
      generating,
      available,
      effective,
      leaseIn,
      leaseOut
    )
  }
  
  implicit class BalanceResponseLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, com.bdmplatform.api.grpc.BalanceResponse]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, com.bdmplatform.api.grpc.BalanceResponse](_l) {
    def bdm: _root_.scalapb.lenses.Lens[UpperPB, com.bdmplatform.api.grpc.BalanceResponse.BdmBalances] = field(_.getBdm)((c_, f_) => c_.copy(balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Bdm(f_)))
    def asset: _root_.scalapb.lenses.Lens[UpperPB, com.bdmplatform.protobuf.Amount] = field(_.getAsset)((c_, f_) => c_.copy(balance = com.bdmplatform.api.grpc.BalanceResponse.Balance.Asset(f_)))
    def balance: _root_.scalapb.lenses.Lens[UpperPB, com.bdmplatform.api.grpc.BalanceResponse.Balance] = field(_.balance)((c_, f_) => c_.copy(balance = f_))
  }
  final val BDM_FIELD_NUMBER = 1
  final val ASSET_FIELD_NUMBER = 2
  def of(
    balance: com.bdmplatform.api.grpc.BalanceResponse.Balance
  ): _root_.com.bdmplatform.api.grpc.BalanceResponse = _root_.com.bdmplatform.api.grpc.BalanceResponse(
    balance
  )
}
